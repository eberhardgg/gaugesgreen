---
import Layout from "../layouts/Layout.astro";

const FALLBACK_METRICS = [
  { key: "touchpoints", label: "Touchpoints", value: "—", target: "120" },
  { key: "conversations", label: "Conversations", value: "—", target: "12" },
  { key: "qualified", label: "Qualified", value: "—", target: "3" },
  { key: "signed", label: "Signed", value: "—", target: "2" },
];

const MODEL = [
  { stage: "Touchpoints", q1Target: "120", eoyTarget: "240", conversion: "10%" },
  { stage: "Conversations", q1Target: "12", eoyTarget: "24", conversion: "25%" },
  { stage: "Qualified", q1Target: "3", eoyTarget: "6", conversion: "33%" },
  { stage: "Signed", q1Target: "2", eoyTarget: "4", conversion: "—" },
];
---

<Layout title="Metrics | Gauges Green" description="Public KPI dashboard for Gauges Green's first year">
  <main class="min-h-screen bg-white dark:bg-[#0a0a0a]">
    <!-- Hero -->
    <section class="pt-12 pb-16 px-6 md:px-8 max-w-2xl mx-auto">
      <h1 class="text-3xl font-semibold text-gray-900 dark:text-white mb-4">
        Metrics
      </h1>
      <p class="text-base text-gray-600 dark:text-gray-400 leading-relaxed">
        How I'm tracking Gauges Green's first year. I work backward from revenue targets and make the assumptions explicit.
      </p>
      <p class="mt-4 text-sm text-gray-500 dark:text-gray-500 italic">
        Live data tracking begins Feb 1, 2026
      </p>
    </section>

    <!-- Current Progress -->
    <section class="py-12 px-6 md:px-8 max-w-2xl mx-auto">
      <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-6">
        Current Progress
      </h2>

      <div class="space-y-4" id="metrics-grid">
        {FALLBACK_METRICS.map((metric) => (
          <div class="p-6 border border-gray-200 dark:border-gray-800" data-metric={metric.key}>
            <div class="flex items-center justify-between">
              <p class="font-semibold text-gray-900 dark:text-white">{metric.label}</p>
              <div class="text-right">
                <span class="text-xl font-semibold text-gray-900 dark:text-white" data-value>{metric.value}</span>
                <span class="text-sm text-gray-500 dark:text-gray-500"> / {metric.target}</span>
              </div>
            </div>
          </div>
        ))}
      </div>
    </section>

    <!-- The Model -->
    <section class="py-12 px-6 md:px-8 max-w-2xl mx-auto">
      <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-2">
        The Model
      </h2>
      <p class="text-base text-gray-600 dark:text-gray-400 mb-6">
        Work backward from revenue. Make assumptions explicit so I know which ones to revisit when reality diverges.
      </p>

      <div class="border border-gray-200 dark:border-gray-800">
        <table class="w-full">
          <thead>
            <tr class="border-b border-gray-200 dark:border-gray-800">
              <th class="text-left p-4 font-semibold text-gray-900 dark:text-white">Stage</th>
              <th class="text-right p-4 font-semibold text-gray-900 dark:text-white">90-Day</th>
              <th class="text-right p-4 font-semibold text-gray-900 dark:text-white">EOY</th>
              <th class="text-right p-4 font-semibold text-gray-900 dark:text-white">Conv.</th>
            </tr>
          </thead>
          <tbody>
            {MODEL.map((row, i) => (
              <tr class={i < MODEL.length - 1 ? "border-b border-gray-200 dark:border-gray-800" : ""}>
                <td class="p-4 text-gray-900 dark:text-white">{row.stage}</td>
                <td class="p-4 text-right text-gray-600 dark:text-gray-400">{row.q1Target}</td>
                <td class="p-4 text-right text-gray-600 dark:text-gray-400">{row.eoyTarget}</td>
                <td class="p-4 text-right text-sm text-gray-500 dark:text-gray-500">{row.conversion}</td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </section>
  </main>
</Layout>

<script is:inline>
  const SHEET_URL = null;

  async function fetchMetrics() {
    if (!SHEET_URL) return;
    try {
      const response = await fetch(SHEET_URL);
      const csv = await response.text();
      const lines = csv.split("\n");
      const headers = lines[0].split(",").map(h => h.trim());
      const metrics = lines.slice(1).filter(line => line.trim()).map(line => {
        const values = line.split(",");
        return headers.reduce((obj, header, i) => {
          obj[header] = values[i]?.trim();
          return obj;
        }, {});
      });
      metrics.forEach(metric => {
        const card = document.querySelector(`[data-metric="${metric.key}"]`);
        if (card) {
          const valueEl = card.querySelector("[data-value]");
          if (valueEl && metric.value) valueEl.textContent = metric.value;
        }
      });
    } catch (error) {
      console.error("Failed to fetch metrics:", error);
    }
  }
  fetchMetrics();
</script>

---
import LayoutMinimal from "../layouts/LayoutMinimal.astro";

const METRICS = [
  { key: "touchpoints", label: "Touchpoints", value: "—", target: "120" },
  { key: "conversations", label: "Conversations", value: "—", target: "12" },
  { key: "qualified", label: "Qualified", value: "—", target: "3" },
  { key: "signed", label: "Signed", value: "—", target: "2" },
];

const MODEL = [
  { stage: "Touchpoints", q1: "120", eoy: "240", conv: "10%" },
  { stage: "Conversations", q1: "12", eoy: "24", conv: "25%" },
  { stage: "Qualified", q1: "3", eoy: "6", conv: "33%" },
  { stage: "Signed", q1: "2", eoy: "4", conv: "—" },
];
---

<LayoutMinimal title="Metrics | Ryan Eberhard" description="Public KPI dashboard for Gauges Green's first year">
  <header class="header">
    <div class="header__inner">
      <a href="/" class="header__logo">Ryan Eberhard</a>
    </div>
    <nav class="header__nav">
      <a href="/">home</a>
      <span class="header__nav-sep">·</span>
      <a href="/experience">experience</a>
      <span class="header__nav-sep">·</span>
      <a href="/services">services</a>
      <span class="header__nav-sep">·</span>
      <a href="/log">writing</a>
      <span class="header__nav-sep">·</span>
      <a href="mailto:eberhard@gaugesgreen.com">contact</a>
    </nav>
  </header>

  <h1>Metrics</h1>
  <p class="intro">
    How I'm tracking Gauges Green's first year. I work backward from revenue targets and make the assumptions explicit.
  </p>
  <p class="note">Live data tracking begins Feb 1, 2026</p>

  <hr />

  <h2>Current Progress</h2>

  <div id="metrics-grid">
    {METRICS.map((metric) => (
      <div class="data-row" data-metric={metric.key}>
        <span class="data-cell--label">{metric.label}</span>
        <span class="data-cell">
          <strong data-value>{metric.value}</strong>
          <span class="data-cell--dim"> / {metric.target}</span>
        </span>
      </div>
    ))}
  </div>

  <hr />

  <h2>The Model</h2>
  <p class="intro">
    Work backward from revenue. Make assumptions explicit so I know which ones to revisit when reality diverges.
  </p>

  <div class="data-row data-row--header">
    <span class="data-cell--label">Stage</span>
    <span class="data-cell">90-Day</span>
    <span class="data-cell">EOY</span>
    <span class="data-cell">Conv.</span>
  </div>
  {MODEL.map((row) => (
    <div class="data-row">
      <span class="data-cell--label">{row.stage}</span>
      <span class="data-cell">{row.q1}</span>
      <span class="data-cell">{row.eoy}</span>
      <span class="data-cell data-cell--dim">{row.conv}</span>
    </div>
  ))}

  <footer class="footer">
    <a href="mailto:eberhard@gaugesgreen.com">email</a>
    <span class="header__nav-sep">·</span>
    <a href="https://linkedin.com/in/eberhard" target="_blank" rel="noopener noreferrer">linkedin</a>
    <span class="header__nav-sep">·</span>
    <a href="https://cal.com/ryan-eberhard-6jsjkn/30min" target="_blank" rel="noopener noreferrer">book a call</a>
  </footer>
</LayoutMinimal>

<script is:inline>
  const SHEET_URL = null;

  async function fetchMetrics() {
    if (!SHEET_URL) return;
    try {
      const response = await fetch(SHEET_URL);
      const csv = await response.text();
      const lines = csv.split("\n");
      const headers = lines[0].split(",").map(h => h.trim());
      const metrics = lines.slice(1).filter(line => line.trim()).map(line => {
        const values = line.split(",");
        return headers.reduce((obj, header, i) => {
          obj[header] = values[i]?.trim();
          return obj;
        }, {});
      });
      metrics.forEach(metric => {
        const row = document.querySelector(`[data-metric="${metric.key}"]`);
        if (row) {
          const valueEl = row.querySelector("[data-value]");
          if (valueEl && metric.value) valueEl.textContent = metric.value;
        }
      });
    } catch (error) {
      console.error("Failed to fetch metrics:", error);
    }
  }
  fetchMetrics();
</script>
